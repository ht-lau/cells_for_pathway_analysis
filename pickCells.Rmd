---
title: "Picking CCLE cell lines for pathway analysis"
output: github_document
---

This is for an R01 application. We want to study cellular signaling using proteomics. The idea is that current knowledge about signaling is very “fuzzy” due to overlapping of signaling components between pathways, e.g. both EGFR and FGFR signal through the MAPK signaling cascade.  

We were criticized about how model CCLE cell lines are picked for the study. So I want to see whether I can find a way to choose the cell lines based on the expression level of the pathway members. 

The read count RNA-seq data are downloaded from the CCLE. The data will have to be normalized before use. To do so, DESeq2 will be used. 

```{r packages, message=FALSE, echo=FALSE}
# required packages
library(tidyverse)
library(ggthemes)
library(DESeq2)
library(robustbase)
library(ggpubr)
```

```{r import data}
# import the raw count data, there are two rows of unwanted materials, so I will have to skip it
raw.counts <- read.delim("../../CCLE_DepMap_18Q2_RNAseq_reads_20180502.gct",
                         header = TRUE, stringsAsFactors = FALSE,
                         skip = 2)
raw.counts[1:5, 1:5]
```

DESeq2 requires a matrix with the gene name as row names and a separated matrix for annotation containing the column names (which is the cell lines in this case).
```{r data import and normalization using DESeq2}
# DESeq2 normalization.
# make the count data matrix
count.data <- as.matrix(raw.counts[, 3:1078])
row.names(count.data) <- raw.counts$Name         # the row names are the Ensembl IDs
count.data[1:5, 1:5]
# annotation matrix, this contain a single column named condition, which is the name of the cell lines
coldata <- as.matrix(data.frame(condition = names(raw.counts[, 3:1078]))) 
row.names(coldata) <- names(raw.counts[, 3:1078])   # also make the cell lines as the col.names
head(coldata, 3)
# create the DESeq object
dds <- DESeqDataSetFromMatrix(countData = count.data,
                              colData = coldata,
                              design = ~condition) # design is just the condition in this case

# then create the normalization factor using estimateSizeFactors()
dds <- estimateSizeFactors(dds)

# retrieve the normalized count using counts(, normalized = TRUE)
nor.CCLE <- raw.counts[, 1:2]
colnames(nor.CCLE) <- c("Ensembl", "Gene.names")
nor.CCLE <- cbind(nor.CCLE, data.frame(counts(dds, normalized = TRUE), stringsAsFactors = FALSE), row.names = NULL)

nor.CCLE[1:5,1:5]
```

Using the EGFR pathway as an example, I want to see what algorithm will provide the most obvious choice cell lines with a high expression of the gene members of a particular pathway. The data of pathway members are be downloaded from reactome.org as .tsv. And I want to try the 1) rank sum, 2) mean, 3) median and the 4) sum of gene expression.

```{r import the genes involved regulations according to Reactome}
# import the EGFR pathway data and extract the member genes
egfr <- read.delim("../../signaling_genes/by_EGFR.tsv", 
                   header = TRUE, stringsAsFactors = FALSE)
egfr <- egfr %>% separate(MoleculeName, into = c("Molecule" , "Gene.name"), sep = " ") %>%
  filter(MoleculeType == "Proteins")
egfr <- egfr$Gene.name[!duplicated(egfr$Gene.name)]
```

```{r try ranking the pathway components}
# Testing which method is best for separating the cell lines
# copy the df into a new df, so the original will not be modified
rank.expression <- nor.CCLE
# Computing the rank sum:
# Rank order all of the gene expressions, producing a matrix
rank.expression <- apply(rank.expression[, 3:1078], 2, 
                         FUN = rank, ties.method = "min")
# add the Ensembl IDs and gene names back to the matrix, produce a df
rank.expression <- cbind(nor.CCLE[, 1:2], rank.expression)
# then select genes that are only in the egfr pathway
egfr.rank <- rank.expression[rank.expression$Gene.names %in% egfr, ]
# add up the rank of the egfr pathway components 
egfr.matrix <- data.frame(Ensembl = rank.expression$Ensembl, stringsAsFactors = FALSE)
egfr.matrix <- data.frame(Rank.sum = colSums(egfr.rank[, 3:1078]), stringsAsFactors = FALSE)

# Median, mean and sum
# make a df containig the normalized expression of egfr components
egfr.ccle <- nor.CCLE[nor.CCLE$Gene.names %in% egfr, ]

egfr.matrix$Median <- robustbase::colMedians(as.matrix(egfr.ccle[, 3:1078]))
egfr.matrix$Mean <- colMeans(as.matrix(egfr.ccle[, 3:1078]))
egfr.matrix$Sum <- colSums(as.matrix(egfr.ccle[, 3:1078]))
```

```{r clean up and visualize}
egfr.matrix$Cell.lines <- row.names(egfr.matrix)
egfr.matrix.long <- egfr.matrix %>% gather(key = "Methods", value = "Expressions", 1:4)

ggplot(egfr.matrix.long) +
  geom_point(mapping = aes(x = Cell.lines, y = Expressions)) +
  facet_wrap(~ Methods, scales = "free_y")
```

Based on the plots, mean and sum seem to give the best separation (they are basically the same). By comparing mean and sum to rank sum and median, it also indicates that the outlier cell lines have certain highly expressed genes within the pathway, but not the over-expression of all of the pathway component annotated by reactome.org. I don't think this will adversely affect the choice of cell lines. Because in the end, we want to see the over-activated and to find out the best marker(s) for a particular pathway.

```{r extracting outlier cells}
cut.off <- quantile(egfr.matrix$Sum, 0.75) + 1.5 * IQR(egfr.matrix$Sum)
egfr.matrix$x.axis <- 1:nrow(egfr.matrix)
egfr.matrix$Picked <- egfr.matrix$Sum >= cut.off
scatter.plot <- ggscatter(egfr.matrix, 
                          x = "x.axis", y = "Sum", 
                          color = "Picked", palette = c("Grey", "Red"))

box <- ggboxplot(egfr.matrix, x = 1, y = "Sum", 
                 alpha = 0.5, 
                 fill = "grey") + clean_theme()

combined.plot <- ggarrange(scatter.plot, box,
          ncol = 2, align = "h",
          widths = c(9, 1), heights = c(1,1),
          common.legend = TRUE)
combined.plot


```

```{r reactome gene list + TCGA oncogenes, echo=FALSE}
########
# can skip, if I am doing the same thing, there is a break point at 
# {r match the signaling component and calculate the sum of expressions}
########


# this part deal with the data I downloaded from the Reactome.
# Mainly, I want to extract the genes involved in each pathway.
# This will produce a list that I can use to match with the CCLE expression data

# There is also a paper published from TCGA looking at the 


# read the files containing the signaling components into a list
signaling.files <- list.files(path = "signaling_genes", pattern = "by_",
                              full.names = TRUE)            # full name extract the path

# use the file list created above to read the files into a list of df
# this dfs contain the data from reactome, which have to clean up further to extract the genes
gene.list <- lapply(signaling.files, read.delim, header = TRUE, stringsAsFactors = FALSE)

# extract the pathway names from the file list
pathway.names <- lapply(signaling.files, str_sub, 20, -5)

# add pathway names back to the file list
names(gene.list) <- pathway.names


############################################################
# The gene.list contains a lot of information that I don't need from the Reactome.
# So write a function to clean it up.
############################################################

extract.genes <- function(x, MoleculeType, MoleculeName) {
  x <- x %>% 
    filter(MoleculeType == "Proteins") %>% 
    separate(MoleculeName, into = c("Uniprot", "Gene.names"), sep = " ")
  x <- x[!duplicated(x$Gene.names), ]
  x <- x$Gene.names
}

# clean up the gene list with the new function
gene.list <- lapply(gene.list, FUN = extract.genes)
names(gene.list) <- str_c("Reactome.", names(gene.list))


# check the common set between RTKs
RTK <- gene.list[c("Reactome.EGFR", "Reactome.FGFR", "Reactome.Insulin_receptor", )]

EGFR.WNT <- gene.list[c("Reactome.EGFR", "Reactome.TCF_Wnt")]

x <- gene.list$Reactome.TCF_Wnt[gene.list$Reactome.TCF_Wnt %in% gene.list$Reactome.EGFR]
y <- gene.list$Reactome.EGFR[gene.list$Reactome.EGFR %in% gene.list$Reactome.TCF_Wnt]
z <- gene.list$Reactome.EGFR[gene.list$Reactome.EGFR %in% gene.list$Reactome.FGFR]
```